// Generated by @compas/code-gen

import type {
  QueryClient,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
} from "@tanstack/react-query";
import type { AxiosInstance, AxiosRequestConfig } from "axios";

import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";

import type { AppErrorResponse } from "generated/common/api-client";
import { useApi } from "generated/common/api-client-wrapper";
import type {
  AuthPasswordBasedForgotPasswordBody,
  AuthPasswordBasedForgotPasswordResponse,
  AuthPasswordBasedListEmailsResponse,
  AuthPasswordBasedLoginBody,
  AuthPasswordBasedResetPasswordBody,
  AuthPasswordBasedResetPasswordResponse,
  AuthPasswordBasedTokenPair,
  AuthPasswordBasedUpdateEmailBody,
  AuthPasswordBasedUpdateEmailResponse,
  AuthPasswordBasedUpdatePasswordBody,
  AuthPasswordBasedUpdatePasswordResponse,
  AuthPasswordBasedVerifyEmailBody,
  AuthPasswordBasedVerifyOtpBody,
  AuthPasswordBasedVerifyOtpResponse,
} from "generated/common/types";

import {
  apiAuthPasswordBasedForgotPassword,
  apiAuthPasswordBasedListEmails,
  apiAuthPasswordBasedLogin,
  apiAuthPasswordBasedResetPassword,
  apiAuthPasswordBasedUpdateEmail,
  apiAuthPasswordBasedUpdatePassword,
  apiAuthPasswordBasedVerifyEmail,
  apiAuthPasswordBasedVerifyOtp,
} from "./apiClient";
/**
 * Generate a reset token for the provided email. Can be called many times. The
 * tokens expire in 24 hours.
 *
 * Errors:
 * - `authPasswordBased.forgotPassword.unknownEmail` -> email is unknown in the
 *   platform
 *
 */
type UseAuthPasswordBasedForgotPasswordProps = AuthPasswordBasedForgotPasswordBody & {
  requestConfig?: AxiosRequestConfig;
};
export function useAuthPasswordBasedForgotPassword(
  options: UseMutationOptions<
    AuthPasswordBasedForgotPasswordResponse,
    AppErrorResponse,
    UseAuthPasswordBasedForgotPasswordProps
  > = {},
): UseMutationResult<
  AuthPasswordBasedForgotPasswordResponse,
  AppErrorResponse,
  UseAuthPasswordBasedForgotPasswordProps,
  unknown
> {
  const axiosInstance = useApi();
  const queryClient = useQueryClient();
  return useMutation(
    variables =>
      apiAuthPasswordBasedForgotPassword(
        axiosInstance,
        { email: variables["email"] },
        variables?.requestConfig,
      ),
    options,
  );
}

export function useAuthPasswordBasedListEmails<TData = AuthPasswordBasedListEmailsResponse>(
  opts: { requestConfig?: AxiosRequestConfig } & {
    queryOptions?: UseQueryOptions<AuthPasswordBasedListEmailsResponse, AppErrorResponse, TData>;
  } = {},
) {
  const axiosInstance = useApi();
  const options = opts?.queryOptions ?? {};
  return useQuery(
    useAuthPasswordBasedListEmails.queryKey(),
    ({ signal }) => {
      opts.requestConfig ??= {};
      opts.requestConfig.signal = signal;

      return apiAuthPasswordBasedListEmails(axiosInstance, opts?.requestConfig);
    },
    options,
  );
}
/**
 * Base key used by useAuthPasswordBasedListEmails.queryKey()
 */
useAuthPasswordBasedListEmails.baseKey = (): QueryKey => ["authPasswordBased", "listEmails"];

/**
 * Query key used by useAuthPasswordBasedListEmails
 */
useAuthPasswordBasedListEmails.queryKey = (): QueryKey => [...useAuthPasswordBasedListEmails.baseKey()];

/**
 * Fetch useAuthPasswordBasedListEmails via the queryClient and return the result
 */
useAuthPasswordBasedListEmails.fetch = (
  queryClient: QueryClient,
  axiosInstance: AxiosInstance,
  opts?: { requestConfig?: AxiosRequestConfig },
) => {
  return queryClient.fetchQuery(useAuthPasswordBasedListEmails.queryKey(), () =>
    apiAuthPasswordBasedListEmails(axiosInstance, opts?.requestConfig),
  );
};

/**
 * Prefetch useAuthPasswordBasedListEmails via the queryClient
 */
useAuthPasswordBasedListEmails.prefetch = (
  queryClient: QueryClient,
  axiosInstance: AxiosInstance,
  opts?: { requestConfig?: AxiosRequestConfig },
) => {
  return queryClient.prefetchQuery(useAuthPasswordBasedListEmails.queryKey(), () =>
    apiAuthPasswordBasedListEmails(axiosInstance, opts?.requestConfig),
  );
};

/**
 * Invalidate useAuthPasswordBasedListEmails via the queryClient
 */
useAuthPasswordBasedListEmails.invalidate = (queryClient: QueryClient) =>
  queryClient.invalidateQueries(useAuthPasswordBasedListEmails.queryKey());

/**
 * Set query data for useAuthPasswordBasedListEmails via the queryClient
 */
useAuthPasswordBasedListEmails.setQueryData = (
  queryClient: QueryClient,

  data: AuthPasswordBasedListEmailsResponse,
) => queryClient.setQueryData(useAuthPasswordBasedListEmails.queryKey(), data);

/**
 * Do a password based login, requires a verified email.
 *
 * Errors:
 * - `authPasswordBased.login.unknownEmail` -> can't find a user with the provider
 *   email
 * - `authPasswordBased.login.emailNotVerified` -> the password login is not
 *   verified
 * - `authPasswordBased.login.maxAttemptsExceeded` -> more then 10 login attempts done in a rolling 5 minute interval
 * - `authPasswordBased.login.invalidEmailPasswordCombination` -> combination of
 *   email and password is invalid
 *
 */
type UseAuthPasswordBasedLoginProps = AuthPasswordBasedLoginBody & { requestConfig?: AxiosRequestConfig };
export function useAuthPasswordBasedLogin(
  options: UseMutationOptions<
    AuthPasswordBasedTokenPair,
    AppErrorResponse,
    UseAuthPasswordBasedLoginProps
  > = {},
): UseMutationResult<AuthPasswordBasedTokenPair, AppErrorResponse, UseAuthPasswordBasedLoginProps, unknown> {
  const axiosInstance = useApi();
  const queryClient = useQueryClient();
  return useMutation(
    variables =>
      apiAuthPasswordBasedLogin(
        axiosInstance,
        { email: variables["email"], password: variables["password"], device: variables["device"] },
        variables?.requestConfig,
      ),
    options,
  );
}

/**
 * Set a new password based on the `resetToken` created via
 * `apiAuthPasswordForgotPassword`. Tokens are removed on usage so this route can't
 * be called multiple times.
 *
 * Errors:
 * - `authPasswordBased.resetPassword.invalidResetToken` -> unknown token or
 *   expired. Let the user request a new token via `forgotPassword`
 * - `authPasswordBased.resetPassword.useVerifyEmail` -> token is a verify token,
 *   use `verifyEmail`
 *
 */
type UseAuthPasswordBasedResetPasswordProps = AuthPasswordBasedResetPasswordBody & {
  requestConfig?: AxiosRequestConfig;
};
export function useAuthPasswordBasedResetPassword(
  options: UseMutationOptions<
    AuthPasswordBasedResetPasswordResponse,
    AppErrorResponse,
    UseAuthPasswordBasedResetPasswordProps
  > = {},
): UseMutationResult<
  AuthPasswordBasedResetPasswordResponse,
  AppErrorResponse,
  UseAuthPasswordBasedResetPasswordProps,
  unknown
> {
  const axiosInstance = useApi();
  const queryClient = useQueryClient();
  return useMutation(
    variables =>
      apiAuthPasswordBasedResetPassword(
        axiosInstance,
        { resetToken: variables["resetToken"], password: variables["password"] },
        variables?.requestConfig,
      ),
    options,
  );
}

/**
 * Let a logged-in user change its email to a different one. Destroys all active
 * sessions afterwards. The user email should be verified again.
 *
 * Errors:
 * - `authPasswordBased.updateEmail.userWithoutPasswordLogin` -> user doesn't have
 *   a password based login, so can't use this functionality
 * - `authPasswordBased.updateEmail.emailAlreadyUsed` -> email is already in use by
 *   another user
 *
 */
type UseAuthPasswordBasedUpdateEmailProps = AuthPasswordBasedUpdateEmailBody & {
  requestConfig?: AxiosRequestConfig;
};
export function useAuthPasswordBasedUpdateEmail(
  options: UseMutationOptions<
    AuthPasswordBasedUpdateEmailResponse,
    AppErrorResponse,
    UseAuthPasswordBasedUpdateEmailProps
  > = {},
): UseMutationResult<
  AuthPasswordBasedUpdateEmailResponse,
  AppErrorResponse,
  UseAuthPasswordBasedUpdateEmailProps,
  unknown
> {
  const axiosInstance = useApi();
  const queryClient = useQueryClient();
  return useMutation(
    variables =>
      apiAuthPasswordBasedUpdateEmail(axiosInstance, { email: variables["email"] }, variables?.requestConfig),
    options,
  );
}

/**
 * Set a new password fort the logged-in user. Destroys all active sessions
 * afterwards.
 *
 * Errors:
 * - `authPasswordBased.updateEmail.userWithoutPasswordLogin` -> user doesn't have
 *   a password based login, so can't use this functionality
 *
 */
type UseAuthPasswordBasedUpdatePasswordProps = AuthPasswordBasedUpdatePasswordBody & {
  requestConfig?: AxiosRequestConfig;
};
export function useAuthPasswordBasedUpdatePassword(
  options: UseMutationOptions<
    AuthPasswordBasedUpdatePasswordResponse,
    AppErrorResponse,
    UseAuthPasswordBasedUpdatePasswordProps
  > = {},
): UseMutationResult<
  AuthPasswordBasedUpdatePasswordResponse,
  AppErrorResponse,
  UseAuthPasswordBasedUpdatePasswordProps,
  unknown
> {
  const axiosInstance = useApi();
  const queryClient = useQueryClient();
  return useMutation(
    variables =>
      apiAuthPasswordBasedUpdatePassword(
        axiosInstance,
        { password: variables["password"] },
        variables?.requestConfig,
      ),
    options,
  );
}

/**
 * Verify an email based on the provided 'verifyToken'. The token is not removed
 * until expired (after 24 hours). Does not throw on multiple calls with the same
 * token. The first verification also updates the `verifiedAt` property on the
 * `passwordLogin` entity. This route returns a token pair for a new session, which can be used to directly log the user in.
 *
 * Errors:
 * - `authPasswordBased.verifyEmail.invalidVerifyToken` -> unknown token or token
 *   expired. Redirect user to do a ' forgotPassword' flow.
 * - `authPasswordBased.verifyEmail.useResetPassword` -> token is for
 *   `resetPassword` instead of `verifyEmail`
 *
 */
type UseAuthPasswordBasedVerifyEmailProps = AuthPasswordBasedVerifyEmailBody & {
  requestConfig?: AxiosRequestConfig;
};
export function useAuthPasswordBasedVerifyEmail(
  options: UseMutationOptions<
    AuthPasswordBasedTokenPair,
    AppErrorResponse,
    UseAuthPasswordBasedVerifyEmailProps
  > = {},
): UseMutationResult<
  AuthPasswordBasedTokenPair,
  AppErrorResponse,
  UseAuthPasswordBasedVerifyEmailProps,
  unknown
> {
  const axiosInstance = useApi();
  const queryClient = useQueryClient();
  return useMutation(
    variables =>
      apiAuthPasswordBasedVerifyEmail(
        axiosInstance,
        { verifyToken: variables["verifyToken"], device: variables["device"] },
        variables?.requestConfig,
      ),
    options,
  );
}

/**
 * Call this when `ctx.session.type === "checkTwoStep"` and `ctx.session.twoStepType === "passwordBasedOtp"`. Advances the session to
 * `type: user` on successful verification.
 *
 */
type UseAuthPasswordBasedVerifyOtpProps = AuthPasswordBasedVerifyOtpBody & {
  requestConfig?: AxiosRequestConfig;
};
export function useAuthPasswordBasedVerifyOtp(
  options: UseMutationOptions<
    AuthPasswordBasedVerifyOtpResponse,
    AppErrorResponse,
    UseAuthPasswordBasedVerifyOtpProps
  > = {},
): UseMutationResult<
  AuthPasswordBasedVerifyOtpResponse,
  AppErrorResponse,
  UseAuthPasswordBasedVerifyOtpProps,
  unknown
> {
  const axiosInstance = useApi();
  const queryClient = useQueryClient();
  return useMutation(
    variables =>
      apiAuthPasswordBasedVerifyOtp(axiosInstance, { otp: variables["otp"] }, variables?.requestConfig),
    options,
  );
}
