// Generated by @compas/code-gen
/* eslint-disable no-unused-vars */

import { useApi, AppErrorResponse } from "../common/reactQuery";
import { AxiosInstance } from "axios";
import {
QueryKey,
UseMutationOptions,
UseMutationResult,
UseQueryOptions,
UseQueryResult,
useMutation,
useQuery,
useQueryClient,
QueryClient,
} from "react-query";
import * as T from "../common/types";
import {
apiAuthGetUser,



apiAuthLogout,



apiAuthMe,



apiAuthRefreshTokens,



apiAuthSetUserActive,



apiAuthUpdateUser,



apiAuthUserList,



} from "./apiClient";



/**
 * Returns a single user.
 *  
 * Errors:
 * - Inherits `authRequireUser` errors with the `auth.getUser` eventKey.
 *  
 * Tags: auth:user:list
*/
export function useAuthGetUser<TData = T.AuthGetUserResponseApi>(opts: {
params: T.AuthGetUserParamsInput,
options?: UseQueryOptions<T.AuthGetUserResponseApi, AppErrorResponse, TData> | undefined,
}) {
const axiosInstance = useApi();
const options = opts?.options ?? {};
options.enabled = (
options.enabled === true || (options.enabled !== false
&& !!opts.params.user
));
return useQuery(useAuthGetUser.queryKey(
opts.params,
),
({ signal }) => {
return apiAuthGetUser(
axiosInstance,
opts.params, 
{ signal },
);
},
options,
);
}
/**
 * Base key used by useAuthGetUser.queryKey()
*/
useAuthGetUser.baseKey = (): QueryKey => ["auth", "getUser"];
/**
 * Query key used by useAuthGetUser
*/
useAuthGetUser.queryKey = (
params: T.AuthGetUserParamsInput,
): QueryKey => [
...useAuthGetUser.baseKey(),
params,
];
/**
 * Fetch useAuthGetUser via the queryClient and return the result
*/
useAuthGetUser.fetch = (
queryClient: QueryClient,
axiosInstance: AxiosInstance,
data: {
params: T.AuthGetUserParamsInput,
}
) => queryClient.fetchQuery(useAuthGetUser.queryKey(
data.params, 
), () => apiAuthGetUser(
axiosInstance,
data.params, 
));
/**
 * Prefetch useAuthGetUser via the queryClient
*/
useAuthGetUser.prefetch = (
queryClient: QueryClient,
axiosInstance: AxiosInstance,
data: {
params: T.AuthGetUserParamsInput,
}
) => queryClient.prefetchQuery(useAuthGetUser.queryKey(
data.params, 
), () => apiAuthGetUser(
axiosInstance,
data.params, 
));
/**
 * Invalidate useAuthGetUser via the queryClient
*/
useAuthGetUser.invalidate = (
queryClient: QueryClient,
axiosInstance: AxiosInstance,
keyInput: {
params: T.AuthGetUserParamsInput,
},
) => queryClient.invalidateQueries(useAuthGetUser.queryKey(
keyInput.params, 
));
/**
 * Set data for useAuthGetUser on the queryClient
*/
useAuthGetUser.setQueryData = (
queryClient: QueryClient,
queryKey: {
params: T.AuthGetUserParamsInput,
},
data: T.AuthGetUserResponseApi,
) => queryClient.setQueryData(useAuthGetUser.queryKey(
queryKey.params,
), data);



interface UseAuthLogoutProps {
}
/**
 * Destroy the current session.
*/
export function useAuthLogout(
options: UseMutationOptions<T.AuthLogoutResponseApi, AppErrorResponse, UseAuthLogoutProps> = {},
): UseMutationResult<T.AuthLogoutResponseApi, AppErrorResponse, UseAuthLogoutProps, unknown> {
const axiosInstance = useApi();
return useMutation(
(variables) => apiAuthLogout(
axiosInstance,
),
options,
);
}



/**
 * Get information about the current logged-in user. Throws a 401 if the user is
 * not logged in. Returns both session and user information. When the user needs to
 * do two-step verification (via 'session.type === checkTwoStep'), the user object is not returned yet.
*/
export function useAuthMe<TData = T.AuthMeResponseApi>(opts?: {
options?: UseQueryOptions<T.AuthMeResponseApi, AppErrorResponse, TData> | undefined,
}|undefined) {
const axiosInstance = useApi();
const options = opts?.options ?? {};
return useQuery(useAuthMe.queryKey(
),
({ signal }) => {
return apiAuthMe(
axiosInstance,
{ signal },
);
},
options,
);
}
/**
 * Base key used by useAuthMe.queryKey()
*/
useAuthMe.baseKey = (): QueryKey => ["auth", "me"];
/**
 * Query key used by useAuthMe
*/
useAuthMe.queryKey = (
): QueryKey => [
...useAuthMe.baseKey(),
];
/**
 * Fetch useAuthMe via the queryClient and return the result
*/
useAuthMe.fetch = (
queryClient: QueryClient,
axiosInstance: AxiosInstance,
) => queryClient.fetchQuery(useAuthMe.queryKey(
), () => apiAuthMe(
axiosInstance,
));
/**
 * Prefetch useAuthMe via the queryClient
*/
useAuthMe.prefetch = (
queryClient: QueryClient,
axiosInstance: AxiosInstance,
) => queryClient.prefetchQuery(useAuthMe.queryKey(
), () => apiAuthMe(
axiosInstance,
));
/**
 * Invalidate useAuthMe via the queryClient
*/
useAuthMe.invalidate = (
queryClient: QueryClient,
axiosInstance: AxiosInstance,
) => queryClient.invalidateQueries(useAuthMe.queryKey(
));
/**
 * Set data for useAuthMe on the queryClient
*/
useAuthMe.setQueryData = (
queryClient: QueryClient,
data: T.AuthMeResponseApi,
) => queryClient.setQueryData(useAuthMe.queryKey(
), data);



interface UseAuthRefreshTokensProps {
body: T.AuthRefreshTokensBodyInput,
}
/**
 * Returns a new token pair based on the provided refresh token.
 *  
 * Errors:
* - Inherits errors from [`sessionStoreRefreshTokens`](https://compasjs.com/features/session-handling.html#sessionstorerefreshtokens)
*/
export function useAuthRefreshTokens(
options: UseMutationOptions<T.AuthTokenPairApi, AppErrorResponse, UseAuthRefreshTokensProps> = {},
): UseMutationResult<T.AuthTokenPairApi, AppErrorResponse, UseAuthRefreshTokensProps, unknown> {
const axiosInstance = useApi();
return useMutation(
(variables) => apiAuthRefreshTokens(
axiosInstance,
variables.body, 
),
options,
);
}



interface UseAuthSetUserActiveProps {
params: T.AuthSetUserActiveParamsInput,
body: T.AuthSetUserActiveBodyInput,
}
/**
 * Soft delete or reactivate a user.
 *  
 * Errors:
 * - Inherits `authRequireUser` errors with the `auth.setUserActive.requireUser`
 * eventKey.
 *  
 * Tags: auth:user:manage
*/
export function useAuthSetUserActive(
options: UseMutationOptions<T.AuthSetUserActiveResponseApi, AppErrorResponse, UseAuthSetUserActiveProps> = {},
): UseMutationResult<T.AuthSetUserActiveResponseApi, AppErrorResponse, UseAuthSetUserActiveProps, unknown> {
const axiosInstance = useApi();
return useMutation(
(variables) => apiAuthSetUserActive(
axiosInstance,
variables.params, 
variables.body, 
),
options,
);
}



interface UseAuthUpdateUserProps {
params: T.AuthUpdateUserParamsInput,
body: T.AuthUpdateUserBodyInput,
}
/**
 * Update base user properties.
 *  
 * Errors:
 * - Inherits `authRequireUser` errors with the `auth.updateUser.requireUser` eventKey.
 *  
 * Tags: auth:user:manage
*/
export function useAuthUpdateUser(
options: UseMutationOptions<T.AuthUpdateUserResponseApi, AppErrorResponse, UseAuthUpdateUserProps> = {},
): UseMutationResult<T.AuthUpdateUserResponseApi, AppErrorResponse, UseAuthUpdateUserProps, unknown> {
const axiosInstance = useApi();
return useMutation(
(variables) => apiAuthUpdateUser(
axiosInstance,
variables.params, 
variables.body, 
),
options,
);
}



/**
 * Return a user list with all settings from this package. Note that the filters
 * are optional. If one of the filters is true, only the users with that type login
 * are returned. If a filter is set to 'false', only users without that login type
 * are returned. The filters are combinable.
 *  
 * Tags: auth:user:list
*/
export function useAuthUserList<TData = T.AuthUserListResponseApi>(opts: {
body: T.AuthUserListBodyInput,
options?: UseQueryOptions<T.AuthUserListResponseApi, AppErrorResponse, TData> | undefined,
}) {
const axiosInstance = useApi();
const options = opts?.options ?? {};
return useQuery(useAuthUserList.queryKey(
opts.body,
),
({ signal }) => {
return apiAuthUserList(
axiosInstance,
opts.body, 
{ signal },
);
},
options,
);
}
/**
 * Base key used by useAuthUserList.queryKey()
*/
useAuthUserList.baseKey = (): QueryKey => ["auth", "userList"];
/**
 * Query key used by useAuthUserList
*/
useAuthUserList.queryKey = (
body: T.AuthUserListBodyInput,
): QueryKey => [
...useAuthUserList.baseKey(),
body,
];
/**
 * Fetch useAuthUserList via the queryClient and return the result
*/
useAuthUserList.fetch = (
queryClient: QueryClient,
axiosInstance: AxiosInstance,
data: {
body: T.AuthUserListBodyInput,
}
) => queryClient.fetchQuery(useAuthUserList.queryKey(
data.body, 
), () => apiAuthUserList(
axiosInstance,
data.body, 
));
/**
 * Prefetch useAuthUserList via the queryClient
*/
useAuthUserList.prefetch = (
queryClient: QueryClient,
axiosInstance: AxiosInstance,
data: {
body: T.AuthUserListBodyInput,
}
) => queryClient.prefetchQuery(useAuthUserList.queryKey(
data.body, 
), () => apiAuthUserList(
axiosInstance,
data.body, 
));
/**
 * Invalidate useAuthUserList via the queryClient
*/
useAuthUserList.invalidate = (
queryClient: QueryClient,
axiosInstance: AxiosInstance,
keyInput: {
body: T.AuthUserListBodyInput,
},
) => queryClient.invalidateQueries(useAuthUserList.queryKey(
keyInput.body, 
));
/**
 * Set data for useAuthUserList on the queryClient
*/
useAuthUserList.setQueryData = (
queryClient: QueryClient,
queryKey: {
body: T.AuthUserListBodyInput,
},
data: T.AuthUserListResponseApi,
) => queryClient.setQueryData(useAuthUserList.queryKey(
queryKey.body,
), data);
