// Generated by @compas/code-gen

export type AuthGetUserParams = {
  user: string;
};

/**
 * Relatively free-form email type. Accepting most valid emails. Emails are case-insensitive.
 */
export type BackendEmail = string;

export type AuthPermissionIdentifier =
  | "test:permission"
  | "auth:user:list"
  | "auth:user:manage"
  | "auth:permission:manage"
  | "auth:keycloak:user:create"
  | "auth:totp:manage"
  | "lightbase:internal";

export type AuthUserSummary = {
  id: string;
  name?: string | undefined;
  lastLogin: string;
  anonymousLogin?:
    | {
        isAllowedToLogin: boolean;
        createdAt: string;
      }
    | undefined;
  digidLogin?:
    | {
        createdAt: string;
      }
    | undefined;
  keycloakLogin?:
    | {
        email: string;
        createdAt: string;
      }
    | undefined;
  passwordLogin?:
    | {
        email: BackendEmail;
        createdAt: string;
        verifiedAt?: string | undefined;
        otpEnabledAt?: string | undefined;
      }
    | undefined;
  totpProvider?:
    | {
        enabledAt: string;
      }
    | undefined;
  roles: {
    id: string;
    identifier: string;
  }[];
  permissions: AuthPermissionIdentifier[];
  createdAt: string;
  deletedAt?: string | undefined;
};

export type AuthGetUserResponse = {
  user: AuthUserSummary;
};

export type AuthImpersonateStopSessionResponse = {
  success: true;
};

export type AuthLogoutResponse = {
  success: true;
};

export type AuthSessionType = "checkTwoStep" | "user" | "passwordBasedUpdatePassword";

export type AuthLoginType = "anonymousBased" | "digidBased" | "keycloakBased" | "passwordBased";

export type AuthTwoStepType = "totpProvider" | "passwordBasedOtp";

export type AuthSession = {
  type: AuthSessionType;
  loginType: AuthLoginType;
  twoStepType?: AuthTwoStepType | undefined;
  userId: string;
  impersonatorUserId?: string | undefined;
};

export type AuthMeResponse = {
  session: AuthSession;
  user?: AuthUserSummary | undefined;
};

export type AuthRefreshTokensBody = {
  refreshToken: string;
};

export type AuthTokenPair = {
  accessToken: string;
  refreshToken: string;
};

export type AuthSetUserActiveParams = {
  user: string;
};

export type AuthSetUserActiveBody = {
  active: boolean | "true" | "false";
};

export type AuthSetUserActiveResponse = {
  success: true;
};

export type AuthUpdateUserParams = {
  user: string;
};

export type AuthUpdateUserBody = {
  name?: string | undefined | null;
};

export type AuthUpdateUserResponse = {
  success: true;
};

export type AuthUserListBody = {
  search?:
    | {
        name?: string | undefined;
      }
    | undefined;
  filters?:
    | {
        anonymousLoginExists?: boolean | "true" | "false" | undefined;
        digidLoginExists?: boolean | "true" | "false" | undefined;
        keycloakLoginExists?: boolean | "true" | "false" | undefined;
        passwordLoginExists?: boolean | "true" | "false" | undefined;
        includeAnonymousTemporarySessions?: boolean | "true" | "false" | undefined;
        includeSoftDeletedUsers?: boolean | "true" | "false" | undefined;
      }
    | undefined;
};

export type AuthUserListResponse = {
  users: AuthUserSummary[];
};

/**
 * Web push information object. This is the result of 'PushSubscription.toJSON()'.
 */
export type SessionWebPushInformation = {
  endpoint: string;
  keys: {
    p256dh: string;
    auth: string;
  };
};

export type SessionLoginDevice = {
  platform: "apple" | "android" | "desktop" | "other";
  name: string;
  notificationToken?: string | undefined;
  webPushInformation?: SessionWebPushInformation | undefined;
};

export type AuthAnonymousBasedLoginBody = {
  token: string;
  device?: SessionLoginDevice | undefined;
};

export type AuthAnonymousBasedTokenPair = {
  accessToken: string;
  refreshToken: string;
};

export type ManagementRequestMagicLinkBody = {
  slackUserId: string;
};

export type ManagementRequestMagicLinkResponse = {
  magicLink?: string | undefined;
};

export type ManagementFeatureFlagListQuery = {
  offset?: number | undefined;
  limit?: number | undefined;
};

export type ManagementFeatureFlagListBody = {
  where?:
    | {
        id?: string | undefined;
        idNotEqual?: string | undefined;
        idIn?: string[] | undefined;
        idNotIn?: string[] | undefined;
        name?: string | undefined;
        nameNotEqual?: string | undefined;
        nameIn?: string[] | undefined;
        nameNotIn?: string[] | undefined;
        nameLike?: string | undefined;
        nameILike?: string | undefined;
        nameNotLike?: string | undefined;
        createdAt?: Date | string | number | undefined;
        createdAtNotEqual?: Date | string | number | undefined;
        createdAtIn?: (Date | string | number)[] | undefined;
        createdAtNotIn?: (Date | string | number)[] | undefined;
        createdAtGreaterThan?: Date | string | number | undefined;
        createdAtLowerThan?: Date | string | number | undefined;
        updatedAt?: Date | string | number | undefined;
        updatedAtNotEqual?: Date | string | number | undefined;
        updatedAtIn?: (Date | string | number)[] | undefined;
        updatedAtNotIn?: (Date | string | number)[] | undefined;
        updatedAtGreaterThan?: Date | string | number | undefined;
        updatedAtLowerThan?: Date | string | number | undefined;
      }
    | undefined;
  orderBy?: ("id" | "name" | "createdAt" | "updatedAt")[] | undefined;
  orderBySpec?:
    | {
        id?: "ASC" | "DESC" | undefined;
        name?: "ASC" | "DESC" | undefined;
        createdAt?: "ASC" | "DESC" | undefined;
        updatedAt?: "ASC" | "DESC" | undefined;
      }
    | undefined;
};

export type ManagementFeatureFlagItem = {
  /**
   * The primary key of the 'featureFlag' model.
   */
  id: string;
  globalValue: boolean;
  description: string;
  name: string;

  /**
   * Specific settings for a tenant. We map the value based on the tenant name. If there is no specific setting for the tenant the globalValue is used.
   */
  tenantValues?: { [key: string]: boolean } | undefined;

  /**
   * Automatically generated 'createdAt', containing an ISO timestamp.
   */
  createdAt: string;

  /**
   * Automatically generated 'updatedAt', containing an ISO timestamp.
   */
  updatedAt: string;
};

export type ManagementFeatureFlagListResponse = {
  list: ManagementFeatureFlagItem[];
  total: number;
};

export type ManagementFeatureFlagSingleParams = {
  /**
   * The primary key of the 'featureFlag' model.
   */
  featureFlagId: string;
};

export type ManagementFeatureFlagSingleResponse = {
  item: ManagementFeatureFlagItem;
};

export type ManagementFeatureFlagUpdateParams = {
  /**
   * The primary key of the 'featureFlag' model.
   */
  featureFlagId: string;
};

export type ManagementFeatureFlagItemWrite = {
  globalValue?: boolean | "true" | "false" | undefined;
  description?: string | undefined;

  /**
   * Specific settings for a tenant. We map the value based on the tenant name. If there is no specific setting for the tenant the globalValue is used.
   */
  tenantValues?: { [key: string]: boolean | "true" | "false" } | undefined;
};

export type ManagementFeatureFlagUpdateResponse = {
  success: true;
};
