// Generated by @compas/code-gen

import type {
  QueryClient,
  QueryKey,
  Updater,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
} from "@tanstack/react-query";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import type { AxiosInstance, AxiosRequestConfig } from "axios";
import type { AppErrorResponse } from "../common/api-client";
import type { Pretty } from "../common/api-client-wrapper";
import { useApi } from "../common/api-client-wrapper";
import type {
  AuthGetUserParams,
  AuthGetUserResponse,
  AuthImpersonateStopSessionResponse,
  AuthLogoutResponse,
  AuthMeResponse,
  AuthRefreshTokensBody,
  AuthSetUserActiveBody,
  AuthSetUserActiveParams,
  AuthSetUserActiveResponse,
  AuthTokenPair,
  AuthUpdateUserBody,
  AuthUpdateUserParams,
  AuthUpdateUserResponse,
  AuthUserListBody,
  AuthUserListResponse,
} from "../common/types";
import {
  apiAuthGetUser,
  apiAuthImpersonateStopSession,
  apiAuthLogout,
  apiAuthMe,
  apiAuthRefreshTokens,
  apiAuthSetUserActive,
  apiAuthUpdateUser,
  apiAuthUserList,
} from "./apiClient";
/**
 * Returns a single user.
 *
 * Errors:
 * - Inherits `authRequireUser` errors with the `auth.getUser` eventKey.
 *
 * Tags: ["auth:user:list"]
 *
 */
export function useAuthGetUser<TData = AuthGetUserResponse>(
  opts: Pretty<
    Partial<
      AuthGetUserParams & { requestConfig?: AxiosRequestConfig } & {
        queryOptions?: Omit<
          UseQueryOptions<AuthGetUserResponse, AppErrorResponse, TData>,
          "queryFn" | "queryKey"
        >;
      }
    >
  >,
) {
  const axiosInstance = useApi();
  const options = opts?.queryOptions ?? {};
  options.enabled =
    options.enabled === true ||
    (options.enabled !== false && opts["user"] !== undefined && opts["user"] !== null);
  return useQuery({
    queryKey: useAuthGetUser.queryKey(opts),
    queryFn: ({ signal }) => {
      if (opts["user"] === undefined || opts["user"] === null) {
        throw new Error(
          "Not all required variables where provided to 'useAuthGetUser'. This happens when you manually set 'queryOptions.enabled' or when you use 'refetch'. Both skip the generated 'queryOptions.enabled'. Make sure that all necessary arguments are set.",
        );
      }

      opts.requestConfig ??= {};
      opts.requestConfig.signal = signal;

      return apiAuthGetUser(axiosInstance, { user: opts["user"] }, opts?.requestConfig);
    },
    ...options,
  });
}
/**
 * Base key used by useAuthGetUser.queryKey()
 */
useAuthGetUser.baseKey = (): QueryKey => ["auth", "getUser"];

/**
 * Query key used by useAuthGetUser
 */
useAuthGetUser.queryKey = (opts: Pretty<Partial<AuthGetUserParams>>): QueryKey => [
  ...useAuthGetUser.baseKey(),
  { user: opts["user"] },
];

/**
 * Fetch useAuthGetUser via the queryClient and return the result
 */
useAuthGetUser.fetch = (
  queryClient: QueryClient,
  axiosInstance: AxiosInstance,
  opts: Pretty<Partial<AuthGetUserParams & { requestConfig?: AxiosRequestConfig }>>,
) => {
  return queryClient.fetchQuery({
    queryKey: useAuthGetUser.queryKey(opts),
    queryFn: () => {
      if (opts["user"] === undefined || opts["user"] === null) {
        throw new Error(
          "Not all required variables where provided to 'useAuthGetUser.fetchQuery'. This happens when you manually set 'queryOptions.enabled' or when you use 'refetch'. Both skip the generated 'queryOptions.enabled'. Make sure that all necessary arguments are set.",
        );
      }

      return apiAuthGetUser(axiosInstance, { user: opts["user"] }, opts?.requestConfig);
    },
  });
};

/**
 * Prefetch useAuthGetUser via the queryClient
 */
useAuthGetUser.prefetch = (
  queryClient: QueryClient,
  axiosInstance: AxiosInstance,
  opts: Pretty<Partial<AuthGetUserParams & { requestConfig?: AxiosRequestConfig }>>,
) => {
  return queryClient.prefetchQuery({
    queryKey: useAuthGetUser.queryKey(opts),
    queryFn: () => {
      if (opts["user"] === undefined || opts["user"] === null) {
        throw new Error(
          "Not all required variables where provided to 'useAuthGetUser.prefetchQuery'. This happens when you manually set 'queryOptions.enabled' or when you use 'refetch'. Both skip the generated 'queryOptions.enabled'. Make sure that all necessary arguments are set.",
        );
      }

      return apiAuthGetUser(axiosInstance, { user: opts["user"] }, opts?.requestConfig);
    },
  });
};

/**
 * Invalidate useAuthGetUser via the queryClient
 */
useAuthGetUser.invalidate = (queryClient: QueryClient, opts: Pretty<Partial<AuthGetUserParams>>) =>
  queryClient.invalidateQueries({ queryKey: useAuthGetUser.queryKey(opts) });

/**
 * Set query data for useAuthGetUser via the queryClient
 */
useAuthGetUser.setQueryData = (
  queryClient: QueryClient,
  opts: Pretty<Partial<AuthGetUserParams>>,
  data: Updater<AuthGetUserResponse, AuthGetUserResponse>,
) => {
  if (opts["user"] === undefined || opts["user"] === null) {
    throw new Error(
      "Not all required variables where provided to 'useAuthGetUser.setQueryData'. This happens when you manually set 'queryOptions.enabled' or when you use 'refetch'. Both skip the generated 'queryOptions.enabled'. Make sure that all necessary arguments are set.",
    );
  }

  return queryClient.setQueryData(useAuthGetUser.queryKey(opts), data);
};

/**
 * Stop an impersonating session. Requires that the current session belongs to the impersonator. Impersonate sessions can only be started from the platform backends.
 *
 * Callers should bust all local caches and redirect the user to the correct location.
 *
 */
type UseAuthImpersonateStopSessionProps = Pretty<{ requestConfig?: AxiosRequestConfig }>;
export function useAuthImpersonateStopSession<Context = unknown>(
  options: UseMutationOptions<
    AuthImpersonateStopSessionResponse,
    AppErrorResponse,
    UseAuthImpersonateStopSessionProps,
    Context
  > = {},
): UseMutationResult<
  AuthImpersonateStopSessionResponse,
  AppErrorResponse,
  UseAuthImpersonateStopSessionProps,
  Context
> {
  const axiosInstance = useApi();
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: variables => apiAuthImpersonateStopSession(axiosInstance, variables?.requestConfig),
    ...options,
  });
}

/**
 * Destroy the current session.
 *
 */
type UseAuthLogoutProps = Pretty<{ requestConfig?: AxiosRequestConfig }>;
export function useAuthLogout<Context = unknown>(
  options: UseMutationOptions<AuthLogoutResponse, AppErrorResponse, UseAuthLogoutProps, Context> = {},
): UseMutationResult<AuthLogoutResponse, AppErrorResponse, UseAuthLogoutProps, Context> {
  const axiosInstance = useApi();
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: variables => apiAuthLogout(axiosInstance, variables?.requestConfig),
    ...options,
  });
}

/**
 * Get information about the current logged-in user. Throws a 401 if the user is
 * not logged in. Returns both session and user information. When the user needs to
 * do two-step verification (via 'session.type === checkTwoStep'), the user object is not returned yet.
 *
 */
export function useAuthMe<TData = AuthMeResponse>(
  opts: Pretty<
    { requestConfig?: AxiosRequestConfig } & {
      queryOptions?: Omit<UseQueryOptions<AuthMeResponse, AppErrorResponse, TData>, "queryFn" | "queryKey">;
    }
  > = {},
) {
  const axiosInstance = useApi();
  const options = opts?.queryOptions ?? {};
  return useQuery({
    queryKey: useAuthMe.queryKey(),
    queryFn: ({ signal }) => {
      opts.requestConfig ??= {};
      opts.requestConfig.signal = signal;

      return apiAuthMe(axiosInstance, opts?.requestConfig);
    },
    ...options,
  });
}
/**
 * Base key used by useAuthMe.queryKey()
 */
useAuthMe.baseKey = (): QueryKey => ["auth", "me"];

/**
 * Query key used by useAuthMe
 */
useAuthMe.queryKey = (): QueryKey => [...useAuthMe.baseKey()];

/**
 * Fetch useAuthMe via the queryClient and return the result
 */
useAuthMe.fetch = (
  queryClient: QueryClient,
  axiosInstance: AxiosInstance,
  opts?: Pretty<{ requestConfig?: AxiosRequestConfig }>,
) => {
  return queryClient.fetchQuery({
    queryKey: useAuthMe.queryKey(),
    queryFn: () => {
      return apiAuthMe(axiosInstance, opts?.requestConfig);
    },
  });
};

/**
 * Prefetch useAuthMe via the queryClient
 */
useAuthMe.prefetch = (
  queryClient: QueryClient,
  axiosInstance: AxiosInstance,
  opts?: Pretty<{ requestConfig?: AxiosRequestConfig }>,
) => {
  return queryClient.prefetchQuery({
    queryKey: useAuthMe.queryKey(),
    queryFn: () => {
      return apiAuthMe(axiosInstance, opts?.requestConfig);
    },
  });
};

/**
 * Invalidate useAuthMe via the queryClient
 */
useAuthMe.invalidate = (queryClient: QueryClient) =>
  queryClient.invalidateQueries({ queryKey: useAuthMe.queryKey() });

/**
 * Set query data for useAuthMe via the queryClient
 */
useAuthMe.setQueryData = (
  queryClient: QueryClient,

  data: Updater<AuthMeResponse, AuthMeResponse>,
) => {
  return queryClient.setQueryData(useAuthMe.queryKey(), data);
};

/**
 * Returns a new token pair based on the provided refresh token.
 *
 * Errors:
 * - Inherits errors from [`sessionStoreRefreshTokens`](https://compasjs.com/features/session-handling.html#sessionstorerefreshtokens)
 *
 */
type UseAuthRefreshTokensProps = Pretty<AuthRefreshTokensBody & { requestConfig?: AxiosRequestConfig }>;
export function useAuthRefreshTokens<Context = unknown>(
  options: UseMutationOptions<AuthTokenPair, AppErrorResponse, UseAuthRefreshTokensProps, Context> = {},
): UseMutationResult<AuthTokenPair, AppErrorResponse, UseAuthRefreshTokensProps, Context> {
  const axiosInstance = useApi();
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: variables =>
      apiAuthRefreshTokens(
        axiosInstance,
        { refreshToken: variables["refreshToken"] },
        variables?.requestConfig,
      ),
    ...options,
  });
}

/**
 * Soft delete or reactivate a user.
 *
 * Errors:
 * - Inherits `authRequireUser` errors with the `auth.setUserActive.requireUser`
 *   eventKey.
 *
 * Tags: ["auth:user:manage"]
 *
 */
type UseAuthSetUserActiveProps = Pretty<
  AuthSetUserActiveParams & AuthSetUserActiveBody & { requestConfig?: AxiosRequestConfig }
>;
export function useAuthSetUserActive<Context = unknown>(
  options: UseMutationOptions<
    AuthSetUserActiveResponse,
    AppErrorResponse,
    UseAuthSetUserActiveProps,
    Context
  > = {},
): UseMutationResult<AuthSetUserActiveResponse, AppErrorResponse, UseAuthSetUserActiveProps, Context> {
  const axiosInstance = useApi();
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: variables =>
      apiAuthSetUserActive(
        axiosInstance,
        { user: variables["user"] },
        { active: variables["active"] },
        variables?.requestConfig,
      ),
    ...options,
  });
}

/**
 * Update base user properties.
 *
 * Errors:
 * - Inherits `authRequireUser` errors with the `auth.updateUser.requireUser` eventKey.
 *
 * Tags: ["auth:user:manage"]
 *
 */
type UseAuthUpdateUserProps = Pretty<
  AuthUpdateUserParams & AuthUpdateUserBody & { requestConfig?: AxiosRequestConfig }
>;
export function useAuthUpdateUser<Context = unknown>(
  options: UseMutationOptions<AuthUpdateUserResponse, AppErrorResponse, UseAuthUpdateUserProps, Context> = {},
): UseMutationResult<AuthUpdateUserResponse, AppErrorResponse, UseAuthUpdateUserProps, Context> {
  const axiosInstance = useApi();
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: variables =>
      apiAuthUpdateUser(
        axiosInstance,
        { user: variables["user"] },
        { name: variables["name"] },
        variables?.requestConfig,
      ),
    ...options,
  });
}

/**
 * Return a user list with all settings from this package. Note that the filters
 * are optional. If one of the filters is true, only the users with that type login
 * are returned. If a filter is set to 'false', only users without that login type
 * are returned. The filters are combinable.
 *
 * Tags: ["auth:user:list"]
 *
 */
export function useAuthUserList<TData = AuthUserListResponse>(
  opts: Pretty<
    AuthUserListBody & { requestConfig?: AxiosRequestConfig } & {
      queryOptions?: Omit<
        UseQueryOptions<AuthUserListResponse, AppErrorResponse, TData>,
        "queryFn" | "queryKey"
      >;
    }
  >,
) {
  const axiosInstance = useApi();
  const options = opts?.queryOptions ?? {};
  return useQuery({
    queryKey: useAuthUserList.queryKey(opts),
    queryFn: ({ signal }) => {
      opts.requestConfig ??= {};
      opts.requestConfig.signal = signal;

      return apiAuthUserList(
        axiosInstance,
        { search: opts["search"], filters: opts["filters"] },
        opts?.requestConfig,
      );
    },
    ...options,
  });
}
/**
 * Base key used by useAuthUserList.queryKey()
 */
useAuthUserList.baseKey = (): QueryKey => ["auth", "userList"];

/**
 * Query key used by useAuthUserList
 */
useAuthUserList.queryKey = (opts: Pretty<AuthUserListBody>): QueryKey => [
  ...useAuthUserList.baseKey(),
  { search: opts["search"] ?? null, filters: opts["filters"] ?? null },
];

/**
 * Fetch useAuthUserList via the queryClient and return the result
 */
useAuthUserList.fetch = (
  queryClient: QueryClient,
  axiosInstance: AxiosInstance,
  opts: Pretty<AuthUserListBody & { requestConfig?: AxiosRequestConfig }>,
) => {
  return queryClient.fetchQuery({
    queryKey: useAuthUserList.queryKey(opts),
    queryFn: () => {
      return apiAuthUserList(
        axiosInstance,
        { search: opts["search"], filters: opts["filters"] },
        opts?.requestConfig,
      );
    },
  });
};

/**
 * Prefetch useAuthUserList via the queryClient
 */
useAuthUserList.prefetch = (
  queryClient: QueryClient,
  axiosInstance: AxiosInstance,
  opts: Pretty<AuthUserListBody & { requestConfig?: AxiosRequestConfig }>,
) => {
  return queryClient.prefetchQuery({
    queryKey: useAuthUserList.queryKey(opts),
    queryFn: () => {
      return apiAuthUserList(
        axiosInstance,
        { search: opts["search"], filters: opts["filters"] },
        opts?.requestConfig,
      );
    },
  });
};

/**
 * Invalidate useAuthUserList via the queryClient
 */
useAuthUserList.invalidate = (queryClient: QueryClient, opts: Pretty<AuthUserListBody>) =>
  queryClient.invalidateQueries({ queryKey: useAuthUserList.queryKey(opts) });

/**
 * Set query data for useAuthUserList via the queryClient
 */
useAuthUserList.setQueryData = (
  queryClient: QueryClient,
  opts: Pretty<AuthUserListBody>,
  data: Updater<AuthUserListResponse, AuthUserListResponse>,
) => {
  return queryClient.setQueryData(useAuthUserList.queryKey(opts), data);
};
